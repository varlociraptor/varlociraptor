<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="Source to the Rust file `/home/travis/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-0.4.28/src/types/monte_carlo.rs`.">
    <meta name="keywords" content="rust, rustlang, rust-lang">

    <title>monte_carlo.rs.html -- source</title>

    <link rel="stylesheet" type="text/css" href="../../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content source"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
</pre><pre class='rust '>
<span class='comment'>//</span>
<span class='comment'>// A rust binding for the GSL library by Guillaume Gomez (guillaume1.gomez@gmail.com)</span>
<span class='comment'>//</span>

<span class='doccomment'>/*!
#Monte Carlo Integration

This chapter describes routines for multidimensional Monte Carlo integration. These include the traditional Monte Carlo method and adaptive 
algorithms such as VEGAS and MISER which use importance sampling and stratified sampling techniques. Each algorithm computes an estimate of 
a multidimensional definite integral of the form,

I = \int_xl^xu dx \int_yl^yu  dy ...  f(x, y, ...)

over a hypercubic region ((x_l,x_u), (y_l,y_u), ...) using a fixed number of function calls. The routines also provide a statistical estimate 
of the error on the result. This error estimate should be taken as a guide rather than as a strict error bound—random sampling of the region 
may not uncover all the important features of the function, resulting in an underestimate of the error.

##Interface

All of the Monte Carlo integration routines use the same general form of interface. There is an allocator to allocate memory for control 
variables and workspace, a routine to initialize those control variables, the integrator itself, and a function to free the space when done.

Each integration function requires a random number generator to be supplied, and returns an estimate of the integral and its standard deviation. 
The accuracy of the result is determined by the number of function calls specified by the user. If a known level of accuracy is required this 
can be achieved by calling the integrator several times and averaging the individual results until the desired accuracy is obtained.

Random sample points used within the Monte Carlo routines are always chosen strictly within the integration region, so that endpoint singularities 
are automatically avoided.

##VEGAS

The VEGAS algorithm of Lepage is based on importance sampling. It samples points from the probability distribution described by the function 
|f|, so that the points are concentrated in the regions that make the largest contribution to the integral.

In general, if the Monte Carlo integral of f is sampled with points distributed according to a probability distribution described by the function 
g, we obtain an estimate E_g(f; N),

E_g(f; N) = E(f/g; N)
with a corresponding variance,

\Var_g(f; N) = \Var(f/g; N).
If the probability distribution is chosen as g = |f|/I(|f|) then it can be shown that the variance V_g(f; N) vanishes, and the error in the 
estimate will be zero. In practice it is not possible to sample from the exact distribution g for an arbitrary function, so importance sampling 
algorithms aim to produce efficient approximations to the desired distribution.

The VEGAS algorithm approximates the exact distribution by making a number of passes over the integration region while histogramming the 
function f. Each histogram is used to define a sampling distribution for the next pass. Asymptotically this procedure converges to the desired 
distribution. In order to avoid the number of histogram bins growing like K^d the probability distribution is approximated by a separable 
function: g(x_1, x_2, ...) = g_1(x_1) g_2(x_2) ... so that the number of bins required is only Kd. This is equivalent to locating the 
peaks of the function from the projections of the integrand onto the coordinate axes. The efficiency of VEGAS depends on the validity of 
this assumption. It is most efficient when the peaks of the integrand are well-localized. If an integrand can be rewritten in a form which 
is approximately separable this will increase the efficiency of integration with VEGAS.

VEGAS incorporates a number of additional features, and combines both stratified sampling and importance sampling. The integration region 
is divided into a number of “boxes”, with each box getting a fixed number of points (the goal is 2). Each box can then have a fractional 
number of bins, but if the ratio of bins-per-box is less than two, Vegas switches to a kind variance reduction (rather than importance 
sampling).

The VEGAS algorithm computes a number of independent estimates of the integral internally, according to the iterations parameter described 
below, and returns their weighted average. Random sampling of the integrand can occasionally produce an estimate where the error is zero, 
particularly if the function is constant in some regions. An estimate with zero error causes the weighted average to break down and must 
be handled separately. In the original Fortran implementations of VEGAS the error estimate is made non-zero by substituting a small value 
(typically 1e-30). The implementation in GSL differs from this and avoids the use of an arbitrary constant—it either assigns the value a 
weight which is the average weight of the preceding estimates or discards it according to the following procedure,

current estimate has zero error, weighted average has finite error
The current estimate is assigned a weight which is the average weight of the preceding estimates.

current estimate has finite error, previous estimates had zero error
The previous estimates are discarded and the weighted averaging procedure begins with the current estimate.

current estimate has zero error, previous estimates had zero error
The estimates are averaged using the arithmetic mean, but no error is computed.
!*/</span>

<span class='kw'>use</span> <span class='ident'>ffi</span>;
<span class='kw'>use</span> <span class='ident'>libc</span>::{<span class='ident'>c_void</span>, <span class='ident'>c_double</span>, <span class='ident'>size_t</span>};
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>slice</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>mem</span>::<span class='ident'>transmute</span>;

<span class='doccomment'>/// The plain Monte Carlo algorithm samples points randomly from the integration region to estimate the integral and its error. Using this algorithm </span>
<span class='doccomment'>/// the estimate of the integral E(f; N) for N randomly distributed points x_i is given by,</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// E(f; N) = =  V &lt;f&gt; = (V / N) \sum_i^N f(x_i)</span>
<span class='doccomment'>/// where V is the volume of the integration region. The error on this estimate \sigma(E;N) is calculated from the estimated variance of the mean,</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// \sigma^2 (E; N) = (V^2 / N^2) \sum_i^N (f(x_i) -  &lt;f&gt;)^2.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// For large N this variance decreases asymptotically as \Var(f)/N, where \Var(f) is the true variance of the function over the integration region. </span>
<span class='doccomment'>/// The error estimate itself should decrease as \sigma(f)/\sqrt{N}. The familiar law of errors decreasing as 1/\sqrt{N} applies—to reduce the </span>
<span class='doccomment'>/// error by a factor of 10 requires a 100-fold increase in the number of sample points.</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>PlainMonteCarlo</span> {
    <span class='ident'>s</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_plain_state</span>,
}

<span class='kw'>impl</span> <span class='ident'>PlainMonteCarlo</span> {
    <span class='doccomment'>/// This function allocates and initializes a workspace for Monte Carlo integration in dim dimensions.</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>dim</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>PlainMonteCarlo</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>tmp</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_plain_alloc</span>(<span class='ident'>dim</span>) };

        <span class='kw'>if</span> <span class='ident'>tmp</span>.<span class='ident'>is_null</span>() {
            <span class='prelude-val'>None</span>
        } <span class='kw'>else</span> {
            <span class='prelude-val'>Some</span>(<span class='ident'>PlainMonteCarlo</span> {
                <span class='ident'>s</span>: <span class='ident'>tmp</span>
            })
        }
    }

    <span class='doccomment'>/// This function initializes a previously allocated integration state. This allows an existing workspace to be reused for different</span>
    <span class='doccomment'>/// integrations.</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>init</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> ::<span class='ident'>Value</span> {
        <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_plain_init</span>(<span class='self'>self</span>.<span class='ident'>s</span>) }
    }

    <span class='doccomment'>/// This routines uses the plain Monte Carlo algorithm to integrate the function f over the dim-dimensional hypercubic region defined</span>
    <span class='doccomment'>/// by the lower and upper limits in the arrays xl and xu, each of the same size. The integration uses a fixed number of function calls</span>
    <span class='doccomment'>/// calls, and obtains random sampling points using the random number generator r. A previously allocated workspace s must be supplied.</span>
    <span class='doccomment'>/// The result of the integration is returned in result, with an estimated absolute error abserr.</span>
    <span class='doccomment'>///</span>
    <span class='doccomment'>/// In C, the function takes a `gsl_monte_function` as first argument. In here, you have to</span>
    <span class='doccomment'>/// pass the `dim` argument and the function pointer (which became a closure) directly to the</span>
    <span class='doccomment'>/// function.</span>
    <span class='doccomment'>///</span>
    <span class='doccomment'>/// It returns either Ok((result, abserr)) or Err(enums::Value).</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>integrate</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>FnMut</span>(<span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>dim</span>: <span class='ident'>usize</span>, <span class='ident'>f</span>: <span class='ident'>F</span>, <span class='ident'>xl</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>xu</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>],
                                              <span class='ident'>t_calls</span>: <span class='ident'>usize</span>, <span class='ident'>r</span>: <span class='kw-2'>&amp;</span>::<span class='ident'>Rng</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span>(<span class='ident'>f64</span>, <span class='ident'>f64</span>), ::<span class='ident'>Value</span><span class='op'>&gt;</span> {
        <span class='kw'>unsafe</span> {
            <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>xl</span>.<span class='ident'>len</span>() <span class='op'>==</span> <span class='ident'>xu</span>.<span class='ident'>len</span>());
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='number'>0f64</span>;
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>abserr</span> <span class='op'>=</span> <span class='number'>0f64</span>;
            <span class='kw'>let</span> <span class='ident'>f</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>FnMut</span>(<span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span><span class='op'>&gt;&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>f</span>));
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>func</span> <span class='op'>=</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_function</span> {
                               <span class='ident'>f</span>: <span class='ident'>transmute</span>(<span class='ident'>monte_trampoline</span> <span class='kw'>as</span> <span class='ident'>usize</span>),
                               <span class='ident'>dim</span>: <span class='ident'>dim</span>,
                               <span class='ident'>params</span>: <span class='ident'>Box</span>::<span class='ident'>into_raw</span>(<span class='ident'>f</span>) <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> _,
                           };
            <span class='kw'>let</span> <span class='ident'>ret</span> <span class='op'>=</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_plain_integrate</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>func</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> _ <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_void</span>,
                                                     <span class='ident'>xl</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>xu</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>xl</span>.<span class='ident'>len</span>(), <span class='ident'>t_calls</span>,
                                                     <span class='ident'>ffi</span>::<span class='ident'>FFI</span>::<span class='ident'>unwrap</span>(<span class='ident'>r</span>), <span class='self'>self</span>.<span class='ident'>s</span>,
                                                     (<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>result</span>) <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_double</span>,
                                                     (<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>abserr</span>) <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_double</span>);

            <span class='kw'>if</span> <span class='ident'>ret</span> <span class='op'>==</span> ::<span class='ident'>Value</span>::<span class='ident'>Success</span> {
                <span class='prelude-val'>Ok</span>((<span class='ident'>result</span>, <span class='ident'>abserr</span>))
            } <span class='kw'>else</span> {
                <span class='prelude-val'>Err</span>(<span class='ident'>ret</span>)
            }
        }
    }
}

<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>PlainMonteCarlo</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_plain_free</span>(<span class='self'>self</span>.<span class='ident'>s</span>) };
        <span class='self'>self</span>.<span class='ident'>s</span> <span class='op'>=</span> ::<span class='ident'>std</span>::<span class='ident'>ptr</span>::<span class='ident'>null_mut</span>();
    }
}

<span class='kw'>impl</span> <span class='ident'>ffi</span>::<span class='ident'>FFI</span><span class='op'>&lt;</span><span class='ident'>ffi</span>::<span class='ident'>gsl_monte_plain_state</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>PlainMonteCarlo</span> {
    <span class='kw'>fn</span> <span class='ident'>wrap</span>(<span class='ident'>s</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_plain_state</span>) <span class='op'>-&gt;</span> <span class='ident'>PlainMonteCarlo</span> {
        <span class='ident'>PlainMonteCarlo</span> {
            <span class='ident'>s</span>: <span class='ident'>s</span>
        }
    }

    <span class='kw'>fn</span> <span class='ident'>unwrap</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>PlainMonteCarlo</span>) <span class='op'>-&gt;</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_plain_state</span> {
        <span class='ident'>s</span>.<span class='ident'>s</span>
    }
}

<span class='doccomment'>/// The MISER algorithm of Press and Farrar is based on recursive stratified sampling. This technique aims to reduce the overall integration error </span>
<span class='doccomment'>/// by concentrating integration points in the regions of highest variance.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// The idea of stratified sampling begins with the observation that for two disjoint regions a and b with Monte Carlo estimates of the integral </span>
<span class='doccomment'>/// E_a(f) and E_b(f) and variances \sigma_a^2(f) and \sigma_b^2(f), the variance \Var(f) of the combined estimate E(f) = (1/2) (E_a(f) + E_b(f)) </span>
<span class='doccomment'>/// is given by,</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// \Var(f) = (\sigma_a^2(f) / 4 N_a) + (\sigma_b^2(f) / 4 N_b).</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// It can be shown that this variance is minimized by distributing the points such that,</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// N_a / (N_a + N_b) = \sigma_a / (\sigma_a + \sigma_b).</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// Hence the smallest error estimate is obtained by allocating sample points in proportion to the standard deviation of the function in each </span>
<span class='doccomment'>/// sub-region.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// The MISER algorithm proceeds by bisecting the integration region along one coordinate axis to give two sub-regions at each step. The direction </span>
<span class='doccomment'>/// is chosen by examining all d possible bisections and selecting the one which will minimize the combined variance of the two sub-regions. The </span>
<span class='doccomment'>/// variance in the sub-regions is estimated by sampling with a fraction of the total number of points available to the current step. The same </span>
<span class='doccomment'>/// procedure is then repeated recursively for each of the two half-spaces from the best bisection. The remaining sample points are allocated to </span>
<span class='doccomment'>/// the sub-regions using the formula for N_a and N_b. This recursive allocation of integration points continues down to a user-specified depth </span>
<span class='doccomment'>/// where each sub-region is integrated using a plain Monte Carlo estimate. These individual values and their error estimates are then combined </span>
<span class='doccomment'>/// upwards to give an overall result and an estimate of its error.</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>MiserMonteCarlo</span> {
    <span class='ident'>s</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_miser_state</span>,
}

<span class='kw'>impl</span> <span class='ident'>MiserMonteCarlo</span> {
    <span class='doccomment'>/// This function allocates and initializes a workspace for Monte Carlo integration in dim dimensions. The workspace is used to maintain</span>
    <span class='doccomment'>/// the state of the integration.</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>dim</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>MiserMonteCarlo</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>tmp_pointer</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_miser_alloc</span>(<span class='ident'>dim</span>) };

        <span class='kw'>if</span> <span class='ident'>tmp_pointer</span>.<span class='ident'>is_null</span>() {
            <span class='prelude-val'>None</span>
        } <span class='kw'>else</span> {
            <span class='prelude-val'>Some</span>(<span class='ident'>MiserMonteCarlo</span> {
                <span class='ident'>s</span>: <span class='ident'>tmp_pointer</span>
            })
        }
    }

    <span class='doccomment'>/// This function initializes a previously allocated integration state. This allows an existing workspace to be reused for different integrations.</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>init</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> ::<span class='ident'>Value</span> {
        <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_miser_init</span>(<span class='self'>self</span>.<span class='ident'>s</span>) }
    }

    <span class='doccomment'>/// This routines uses the MISER Monte Carlo algorithm to integrate the function f over the dim-dimensional hypercubic region defined by</span>
    <span class='doccomment'>/// the lower and upper limits in the arrays xl and xu, each of size dim. The integration uses a fixed number of function calls calls,</span>
    <span class='doccomment'>/// and obtains random sampling points using the random number generator r. A previously allocated workspace s must be supplied. The result</span>
    <span class='doccomment'>/// of the integration is returned in result, with an estimated absolute error abserr.</span>
    <span class='doccomment'>///</span>
    <span class='doccomment'>/// In C, the function takes a `gsl_monte_function` as first argument. In here, you have to</span>
    <span class='doccomment'>/// pass the `dim` argument and the function pointer (which became a closure) directly to the</span>
    <span class='doccomment'>/// function.</span>
    <span class='doccomment'>///</span>
    <span class='doccomment'>/// It returns either Ok((result, abserr)) or Err(enums::Value).</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>integrate</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>FnMut</span>(<span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>dim</span>: <span class='ident'>usize</span>, <span class='ident'>f</span>: <span class='ident'>F</span>, <span class='ident'>xl</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>xu</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>],
                                              <span class='ident'>t_calls</span>: <span class='ident'>usize</span>, <span class='ident'>r</span>: <span class='kw-2'>&amp;</span>::<span class='ident'>Rng</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span>(<span class='ident'>f64</span>, <span class='ident'>f64</span>), ::<span class='ident'>Value</span><span class='op'>&gt;</span> {
        <span class='kw'>unsafe</span> {
            <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>xl</span>.<span class='ident'>len</span>() <span class='op'>==</span> <span class='ident'>xu</span>.<span class='ident'>len</span>());
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='number'>0f64</span>;
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>abserr</span> <span class='op'>=</span> <span class='number'>0f64</span>;
            <span class='kw'>let</span> <span class='ident'>f</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>FnMut</span>(<span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span><span class='op'>&gt;&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>f</span>));
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>func</span> <span class='op'>=</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_function</span> {
                               <span class='ident'>f</span>: <span class='ident'>transmute</span>(<span class='ident'>monte_trampoline</span> <span class='kw'>as</span> <span class='ident'>usize</span>),
                               <span class='ident'>dim</span>: <span class='ident'>dim</span>,
                               <span class='ident'>params</span>: <span class='ident'>Box</span>::<span class='ident'>into_raw</span>(<span class='ident'>f</span>) <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> _,
                           };
            <span class='kw'>let</span> <span class='ident'>ret</span> <span class='op'>=</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_miser_integrate</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>func</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> _ <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_void</span>,
                                                     <span class='ident'>xl</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>xu</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>xl</span>.<span class='ident'>len</span>(), <span class='ident'>t_calls</span>,
                                                     <span class='ident'>ffi</span>::<span class='ident'>FFI</span>::<span class='ident'>unwrap</span>(<span class='ident'>r</span>), <span class='self'>self</span>.<span class='ident'>s</span>,
                                                     (<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>result</span>) <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_double</span>,
                                                     (<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>abserr</span>) <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_double</span>);

            <span class='kw'>if</span> <span class='ident'>ret</span> <span class='op'>==</span> ::<span class='ident'>Value</span>::<span class='ident'>Success</span> {
                <span class='prelude-val'>Ok</span>((<span class='ident'>result</span>, <span class='ident'>abserr</span>))
            } <span class='kw'>else</span> {
                <span class='prelude-val'>Err</span>(<span class='ident'>ret</span>)
            }
        }
    }

    <span class='doccomment'>/// This function copies the parameters of the integrator state into the user-supplied params structure.</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>get_params</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>MiserParams</span> {
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>m</span> <span class='op'>=</span> <span class='ident'>MiserParams</span> {
            <span class='ident'>estimate_frac</span>: <span class='number'>0f64</span>,
            <span class='ident'>min_calls</span>: <span class='number'>0</span>,
            <span class='ident'>min_calls_per_bisection</span>: <span class='number'>0</span>,
            <span class='ident'>alpha</span>: <span class='number'>0f64</span>,
            <span class='ident'>dither</span>: <span class='number'>0f64</span>,
        };

        <span class='kw'>unsafe</span> {
            <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_miser_params_get</span>(<span class='self'>self</span>.<span class='ident'>s</span>, <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>m</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>MiserParams</span>);
        }
        <span class='ident'>m</span>
    }

    <span class='doccomment'>/// This function sets the integrator parameters based on values provided in the params structure.</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>set_params</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>params</span>: <span class='kw-2'>&amp;</span><span class='ident'>MiserParams</span>) {
        <span class='kw'>unsafe</span> {
            <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_miser_params_set</span>(<span class='self'>self</span>.<span class='ident'>s</span>, <span class='ident'>params</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw'>const</span> <span class='ident'>MiserParams</span>);
        }
    }
}

<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>MiserMonteCarlo</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_miser_free</span>(<span class='self'>self</span>.<span class='ident'>s</span>) };
        <span class='self'>self</span>.<span class='ident'>s</span> <span class='op'>=</span> ::<span class='ident'>std</span>::<span class='ident'>ptr</span>::<span class='ident'>null_mut</span>();
    }
}

<span class='kw'>impl</span> <span class='ident'>ffi</span>::<span class='ident'>FFI</span><span class='op'>&lt;</span><span class='ident'>ffi</span>::<span class='ident'>gsl_monte_miser_state</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>MiserMonteCarlo</span> {
    <span class='kw'>fn</span> <span class='ident'>wrap</span>(<span class='ident'>s</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_miser_state</span>) <span class='op'>-&gt;</span> <span class='ident'>MiserMonteCarlo</span> {
        <span class='ident'>MiserMonteCarlo</span> {
            <span class='ident'>s</span>: <span class='ident'>s</span>
        }
    }

    <span class='kw'>fn</span> <span class='ident'>unwrap</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>MiserMonteCarlo</span>) <span class='op'>-&gt;</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_miser_state</span> {
        <span class='ident'>s</span>.<span class='ident'>s</span>
    }
}

<span class='attribute'>#[<span class='ident'>repr</span>(<span class='ident'>C</span>)]</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>MiserParams</span> {
    <span class='doccomment'>/// This parameter specifies the fraction of the currently available number of function calls which</span>
    <span class='doccomment'>/// are allocated to estimating the variance at each recursive step. The default value is 0.1.</span>
    <span class='kw'>pub</span> <span class='ident'>estimate_frac</span>: <span class='ident'>f64</span>,
    <span class='doccomment'>/// This parameter specifies the minimum number of function calls required for each estimate of the</span>
    <span class='doccomment'>/// variance. If the number of function calls allocated to the estimate using estimate_frac falls</span>
    <span class='doccomment'>/// below min_calls then min_calls are used instead. This ensures that each estimate maintains a</span>
    <span class='doccomment'>/// reasonable level of accuracy. The default value of min_calls is 16 * dim.</span>
    <span class='kw'>pub</span> <span class='ident'>min_calls</span>: <span class='ident'>usize</span>,
    <span class='doccomment'>/// This parameter specifies the minimum number of function calls required to proceed with a bisection</span>
    <span class='doccomment'>/// step. When a recursive step has fewer calls available than min_calls_per_bisection it performs</span>
    <span class='doccomment'>/// a plain Monte Carlo estimate of the current sub-region and terminates its branch of the recursion.</span>
    <span class='doccomment'>/// The default value of this parameter is 32 * min_calls.</span>
    <span class='kw'>pub</span> <span class='ident'>min_calls_per_bisection</span>: <span class='ident'>usize</span>,
    <span class='doccomment'>/// This parameter controls how the estimated variances for the two sub-regions of a bisection are</span>
    <span class='doccomment'>/// combined when allocating points. With recursive sampling the overall variance should scale better</span>
    <span class='doccomment'>/// than 1/N, since the values from the sub-regions will be obtained using a procedure which explicitly</span>
    <span class='doccomment'>/// minimizes their variance. To accommodate this behavior the MISER algorithm allows the total variance</span>
    <span class='doccomment'>/// to depend on a scaling parameter \alpha,</span>
    <span class='doccomment'>///</span>
    <span class='doccomment'>/// \Var(f) = {\sigma_a \over N_a^\alpha} + {\sigma_b \over N_b^\alpha}.</span>
    <span class='doccomment'>/// </span>
    <span class='doccomment'>/// The authors of the original paper describing MISER recommend the value \alpha = 2 as a good choice,</span>
    <span class='doccomment'>/// obtained from numerical experiments, and this is used as the default value in this implementation.</span>
    <span class='kw'>pub</span> <span class='ident'>alpha</span>: <span class='ident'>f64</span>,
    <span class='doccomment'>/// This parameter introduces a random fractional variation of size dither into each bisection, which</span>
    <span class='doccomment'>/// can be used to break the symmetry of integrands which are concentrated near the exact center of</span>
    <span class='doccomment'>/// the hypercubic integration region. The default value of dither is zero, so no variation is introduced.</span>
    <span class='doccomment'>/// If needed, a typical value of dither is 0.1.</span>
    <span class='kw'>pub</span> <span class='ident'>dither</span>: <span class='ident'>f64</span>,
}

<span class='doccomment'>/// The VEGAS algorithm of Lepage is based on importance sampling. It samples points from the probability</span>
<span class='doccomment'>/// distribution described by the function |f|, so that the points are concentrated in the regions that</span>
<span class='doccomment'>/// make the largest contribution to the integral.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// In general, if the Monte Carlo integral of f is sampled with points distributed according to a</span>
<span class='doccomment'>/// probability distribution described by the function g, we obtain an estimate E_g(f; N),</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// E_g(f; N) = E(f/g; N)</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// with a corresponding variance,</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// \Var_g(f; N) = \Var(f/g; N).</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// If the probability distribution is chosen as g = |f|/I(|f|) then it can be shown that the variance</span>
<span class='doccomment'>/// V_g(f; N) vanishes, and the error in the estimate will be zero. In practice it is not possible to</span>
<span class='doccomment'>/// sample from the exact distribution g for an arbitrary function, so importance sampling algorithms</span>
<span class='doccomment'>/// aim to produce efficient approximations to the desired distribution.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// The VEGAS algorithm approximates the exact distribution by making a number of passes over the</span>
<span class='doccomment'>/// integration region while histogramming the function f. Each histogram is used to define a sampling</span>
<span class='doccomment'>/// distribution for the next pass. Asymptotically this procedure converges to the desired distribution.</span>
<span class='doccomment'>/// In order to avoid the number of histogram bins growing like K^d the probability distribution is</span>
<span class='doccomment'>/// approximated by a separable function: g(x_1, x_2, ...) = g_1(x_1) g_2(x_2) ... so that the number</span>
<span class='doccomment'>/// of bins required is only Kd. This is equivalent to locating the peaks of the function from the</span>
<span class='doccomment'>/// projections of the integrand onto the coordinate axes. The efficiency of VEGAS depends on the</span>
<span class='doccomment'>/// validity of this assumption. It is most efficient when the peaks of the integrand are well-localized.</span>
<span class='doccomment'>/// If an integrand can be rewritten in a form which is approximately separable this will increase</span>
<span class='doccomment'>/// the efficiency of integration with VEGAS.</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// VEGAS incorporates a number of additional features, and combines both stratified sampling and</span>
<span class='doccomment'>/// importance sampling. The integration region is divided into a number of “boxes”, with each box</span>
<span class='doccomment'>/// getting a fixed number of points (the goal is 2). Each box can then have a fractional number of</span>
<span class='doccomment'>/// bins, but if the ratio of bins-per-box is less than two, Vegas switches to a kind variance reduction</span>
<span class='doccomment'>/// (rather than importance sampling).</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// The VEGAS algorithm computes a number of independent estimates of the integral internally, according</span>
<span class='doccomment'>/// to the iterations parameter described below, and returns their weighted average. Random sampling of</span>
<span class='doccomment'>/// the integrand can occasionally produce an estimate where the error is zero, particularly if the function</span>
<span class='doccomment'>/// is constant in some regions. An estimate with zero error causes the weighted average to break down and</span>
<span class='doccomment'>/// must be handled separately. In the original Fortran implementations of VEGAS the error estimate is made</span>
<span class='doccomment'>/// non-zero by substituting a small value (typically 1e-30). The implementation in GSL differs from this</span>
<span class='doccomment'>/// and avoids the use of an arbitrary constant—it either assigns the value a weight which is the average</span>
<span class='doccomment'>/// weight of the preceding estimates or discards it according to the following procedure,</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// current estimate has zero error, weighted average has finite error</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// * The current estimate is assigned a weight which is the average weight of the preceding estimates.</span>
<span class='doccomment'>/// current estimate has finite error, previous estimates had zero error</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// * The previous estimates are discarded and the weighted averaging procedure begins with the current estimate.</span>
<span class='doccomment'>/// current estimate has zero error, previous estimates had zero error</span>
<span class='doccomment'>///</span>
<span class='doccomment'>/// * The estimates are averaged using the arithmetic mean, but no error is computed.</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>VegasMonteCarlo</span> {
    <span class='ident'>s</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_vegas_state</span>,
}

<span class='kw'>impl</span> <span class='ident'>VegasMonteCarlo</span> {
    <span class='doccomment'>/// This function allocates and initializes a workspace for Monte Carlo integration in dim dimensions.</span>
    <span class='doccomment'>/// The workspace is used to maintain the state of the integration.</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>dim</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Option</span><span class='op'>&lt;</span><span class='ident'>VegasMonteCarlo</span><span class='op'>&gt;</span> {
        <span class='kw'>let</span> <span class='ident'>tmp_pointer</span> <span class='op'>=</span> <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_vegas_alloc</span>(<span class='ident'>dim</span>) };

        <span class='kw'>if</span> <span class='ident'>tmp_pointer</span>.<span class='ident'>is_null</span>() {
            <span class='prelude-val'>None</span>
        } <span class='kw'>else</span> {
            <span class='prelude-val'>Some</span>(<span class='ident'>VegasMonteCarlo</span> {
                <span class='ident'>s</span>: <span class='ident'>tmp_pointer</span>
            })
        }
    }

    <span class='doccomment'>/// This function initializes a previously allocated integration state. This allows an existing workspace</span>
    <span class='doccomment'>/// to be reused for different integrations.</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>init</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> ::<span class='ident'>Value</span> {
        <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_vegas_init</span>(<span class='self'>self</span>.<span class='ident'>s</span>) }
    }

    <span class='doccomment'>/// This routines uses the VEGAS Monte Carlo algorithm to integrate the function f over the dim-dimensional</span>
    <span class='doccomment'>/// hypercubic region defined by the lower and upper limits in the arrays xl and xu, each of size dim.</span>
    <span class='doccomment'>/// The integration uses a fixed number of function calls calls, and obtains random sampling points using</span>
    <span class='doccomment'>/// the random number generator r. A previously allocated workspace s must be supplied. The result of the</span>
    <span class='doccomment'>/// integration is returned in result, with an estimated absolute error abserr. The result and its error</span>
    <span class='doccomment'>/// estimate are based on a weighted average of independent samples. The chi-squared per degree of freedom</span>
    <span class='doccomment'>/// for the weighted average is returned via the state struct component, s-&gt;chisq, and must be consistent</span>
    <span class='doccomment'>/// with 1 for the weighted average to be reliable.</span>
    <span class='doccomment'>///</span>
    <span class='doccomment'>/// In C, the function takes a `gsl_monte_function` as first argument. In here, you have to</span>
    <span class='doccomment'>/// pass the `dim` argument and the function pointer (which became a closure) directly to the</span>
    <span class='doccomment'>/// function.</span>
    <span class='doccomment'>///</span>
    <span class='doccomment'>/// It returns either Ok((result, abserr)) or Err(enums::Value).</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>integrate</span><span class='op'>&lt;</span><span class='ident'>F</span>: <span class='ident'>FnMut</span>(<span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span><span class='op'>&gt;</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>dim</span>: <span class='ident'>usize</span>, <span class='ident'>f</span>: <span class='ident'>F</span>, <span class='ident'>xl</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>xu</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>],
                                              <span class='ident'>t_calls</span>: <span class='ident'>usize</span>, <span class='ident'>r</span>: <span class='kw-2'>&amp;</span>::<span class='ident'>Rng</span>) <span class='op'>-&gt;</span> <span class='prelude-ty'>Result</span><span class='op'>&lt;</span>(<span class='ident'>f64</span>, <span class='ident'>f64</span>), ::<span class='ident'>Value</span><span class='op'>&gt;</span> {
        <span class='kw'>unsafe</span> {
            <span class='macro'>assert</span><span class='macro'>!</span>(<span class='ident'>xl</span>.<span class='ident'>len</span>() <span class='op'>==</span> <span class='ident'>xu</span>.<span class='ident'>len</span>());
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>result</span> <span class='op'>=</span> <span class='number'>0f64</span>;
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>abserr</span> <span class='op'>=</span> <span class='number'>0f64</span>;
            <span class='kw'>let</span> <span class='ident'>f</span>: <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>FnMut</span>(<span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span><span class='op'>&gt;&gt;</span> <span class='op'>=</span> <span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>Box</span>::<span class='ident'>new</span>(<span class='ident'>f</span>));
            <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>func</span> <span class='op'>=</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_function</span> {
                               <span class='ident'>f</span>: <span class='ident'>transmute</span>(<span class='ident'>monte_trampoline</span> <span class='kw'>as</span> <span class='ident'>usize</span>),
                               <span class='ident'>dim</span>: <span class='ident'>dim</span>,
                               <span class='ident'>params</span>: <span class='ident'>Box</span>::<span class='ident'>into_raw</span>(<span class='ident'>f</span>) <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> _,
                           };
            <span class='kw'>let</span> <span class='ident'>ret</span> <span class='op'>=</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_vegas_integrate</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>func</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> _ <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_void</span>,
                                                     <span class='ident'>xl</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>xu</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>xl</span>.<span class='ident'>len</span>(), <span class='ident'>t_calls</span>,
                                                     <span class='ident'>ffi</span>::<span class='ident'>FFI</span>::<span class='ident'>unwrap</span>(<span class='ident'>r</span>), <span class='self'>self</span>.<span class='ident'>s</span>,
                                                     (<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>result</span>) <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_double</span>,
                                                     (<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>abserr</span>) <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_double</span>);

            <span class='kw'>if</span> <span class='ident'>ret</span> <span class='op'>==</span> ::<span class='ident'>Value</span>::<span class='ident'>Success</span> {
                <span class='prelude-val'>Ok</span>((<span class='ident'>result</span>, <span class='ident'>abserr</span>))
            } <span class='kw'>else</span> {
                <span class='prelude-val'>Err</span>(<span class='ident'>ret</span>)
            }
        }
    }

    <span class='doccomment'>/// This function returns the chi-squared per degree of freedom for the weighted estimate of the integral.</span>
    <span class='doccomment'>/// The returned value should be close to 1. A value which differs significantly from 1 indicates that</span>
    <span class='doccomment'>/// the values from different iterations are inconsistent. In this case the weighted error will be</span>
    <span class='doccomment'>/// under-estimated, and further iterations of the algorithm are needed to obtain reliable results.</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>chisq</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='kw'>unsafe</span> {
            <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_vegas_chisq</span>(<span class='self'>self</span>.<span class='ident'>s</span>)
        }
    }

    <span class='doccomment'>/// This function returns the raw (unaveraged) values of the integral result and its error sigma from</span>
    <span class='doccomment'>/// the most recent iteration of the algorithm.</span>
    <span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>runval</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>result</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>f64</span>, <span class='ident'>sigma</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>f64</span>) {
        <span class='kw'>unsafe</span> {
            <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_vegas_runval</span>(<span class='self'>self</span>.<span class='ident'>s</span>, <span class='ident'>result</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_double</span>, <span class='ident'>sigma</span> <span class='kw'>as</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_double</span>)
        }
    }

    <span class='comment'>/*pub params_get(&amp;self) -&gt; VegasParams {
        ;
    }

    pub params_set(&amp;self, params: &amp;VegasParams) {
        ;
    }*/</span>
}

<span class='kw'>impl</span> <span class='ident'>Drop</span> <span class='kw'>for</span> <span class='ident'>VegasMonteCarlo</span> {
    <span class='kw'>fn</span> <span class='ident'>drop</span>(<span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='self'>self</span>) {
        <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_vegas_free</span>(<span class='self'>self</span>.<span class='ident'>s</span>) };
        <span class='self'>self</span>.<span class='ident'>s</span> <span class='op'>=</span> ::<span class='ident'>std</span>::<span class='ident'>ptr</span>::<span class='ident'>null_mut</span>();
    }
}

<span class='kw'>impl</span> <span class='ident'>ffi</span>::<span class='ident'>FFI</span><span class='op'>&lt;</span><span class='ident'>ffi</span>::<span class='ident'>gsl_monte_vegas_state</span><span class='op'>&gt;</span> <span class='kw'>for</span> <span class='ident'>VegasMonteCarlo</span> {
    <span class='kw'>fn</span> <span class='ident'>wrap</span>(<span class='ident'>s</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_vegas_state</span>) <span class='op'>-&gt;</span> <span class='ident'>VegasMonteCarlo</span> {
        <span class='ident'>VegasMonteCarlo</span> {
            <span class='ident'>s</span>: <span class='ident'>s</span>
        }
    }

    <span class='kw'>fn</span> <span class='ident'>unwrap</span>(<span class='ident'>s</span>: <span class='kw-2'>&amp;</span><span class='ident'>VegasMonteCarlo</span>) <span class='op'>-&gt;</span> <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>ffi</span>::<span class='ident'>gsl_monte_vegas_state</span> {
        <span class='ident'>s</span>.<span class='ident'>s</span>
    }
}

<span class='kw'>unsafe</span> <span class='kw'>extern</span> <span class='string'>&quot;C&quot;</span> <span class='kw'>fn</span> <span class='ident'>monte_trampoline</span>(<span class='ident'>x</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_double</span>, <span class='ident'>dim</span>: <span class='ident'>size_t</span>, <span class='ident'>param</span>: <span class='op'>*</span><span class='kw-2'>mut</span> <span class='ident'>c_void</span>) <span class='op'>-&gt;</span> <span class='ident'>c_double</span> {
    <span class='kw'>let</span> <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>Box</span><span class='op'>&lt;</span><span class='ident'>FnMut</span>(<span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>transmute</span>(<span class='ident'>param</span>);
    <span class='ident'>f</span>(<span class='ident'>slice</span>::<span class='ident'>from_raw_parts</span>(<span class='ident'>x</span>, <span class='ident'>dim</span> <span class='kw'>as</span> <span class='ident'>usize</span>))
}


<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>plain</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span>;
    <span class='kw'>fn</span> <span class='ident'>g</span>(<span class='ident'>k</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='number'>1f64</span> <span class='op'>/</span> (<span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>PI</span>);

        <span class='ident'>a</span> <span class='op'>/</span> (<span class='number'>1.0</span> <span class='op'>-</span> <span class='ident'>k</span>[<span class='number'>0</span>].<span class='ident'>cos</span>() <span class='op'>*</span> <span class='ident'>k</span>[<span class='number'>1</span>].<span class='ident'>cos</span>() <span class='op'>*</span> <span class='ident'>k</span>[<span class='number'>2</span>].<span class='ident'>cos</span>())
    }

    <span class='kw'>let</span> <span class='ident'>xl</span> : [<span class='ident'>f64</span>; <span class='number'>3</span>] <span class='op'>=</span> [<span class='number'>0f64</span>; <span class='number'>3</span>];
    <span class='kw'>let</span> <span class='ident'>xu</span> : [<span class='ident'>f64</span>; <span class='number'>3</span>] <span class='op'>=</span> [<span class='ident'>PI</span>, <span class='ident'>PI</span>, <span class='ident'>PI</span>];

    <span class='kw'>let</span> <span class='ident'>calls</span> <span class='op'>=</span> <span class='number'>500000</span>;

    ::<span class='ident'>RngType</span>::<span class='ident'>env_setup</span>();
    <span class='kw'>let</span> <span class='ident'>t</span> : ::<span class='ident'>RngType</span> <span class='op'>=</span> ::<span class='ident'>rng</span>::<span class='ident'>default</span>();
    <span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> ::<span class='ident'>Rng</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='ident'>t</span>).<span class='ident'>unwrap</span>();

    {
        <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>PlainMonteCarlo</span>::<span class='ident'>new</span>(<span class='number'>3</span>).<span class='ident'>unwrap</span>();

        <span class='kw'>let</span> (<span class='ident'>res</span>, <span class='ident'>err</span>) <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>integrate</span>(<span class='number'>3</span>, <span class='ident'>g</span>, <span class='kw-2'>&amp;</span><span class='ident'>xl</span>, <span class='kw-2'>&amp;</span><span class='ident'>xu</span>, <span class='ident'>calls</span>, <span class='kw-2'>&amp;</span><span class='ident'>r</span>).<span class='ident'>unwrap</span>();
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:.6}&quot;</span>, <span class='ident'>res</span>), <span class='string'>&quot;1.412209&quot;</span>);
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:.6}&quot;</span>, <span class='ident'>err</span>), <span class='string'>&quot;0.013436&quot;</span>);
    }
}

<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>miser</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span>;
    <span class='kw'>fn</span> <span class='ident'>g</span>(<span class='ident'>k</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='number'>1f64</span> <span class='op'>/</span> (<span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>PI</span>);

        <span class='ident'>a</span> <span class='op'>/</span> (<span class='number'>1.0</span> <span class='op'>-</span> <span class='ident'>k</span>[<span class='number'>0</span>].<span class='ident'>cos</span>() <span class='op'>*</span> <span class='ident'>k</span>[<span class='number'>1</span>].<span class='ident'>cos</span>() <span class='op'>*</span> <span class='ident'>k</span>[<span class='number'>2</span>].<span class='ident'>cos</span>())
    }

    <span class='kw'>let</span> <span class='ident'>xl</span> : [<span class='ident'>f64</span>; <span class='number'>3</span>] <span class='op'>=</span> [<span class='number'>0f64</span>; <span class='number'>3</span>];
    <span class='kw'>let</span> <span class='ident'>xu</span> : [<span class='ident'>f64</span>; <span class='number'>3</span>] <span class='op'>=</span> [<span class='ident'>PI</span>, <span class='ident'>PI</span>, <span class='ident'>PI</span>];

    <span class='kw'>let</span> <span class='ident'>calls</span> <span class='op'>=</span> <span class='number'>500000</span>;

    ::<span class='ident'>RngType</span>::<span class='ident'>env_setup</span>();
    <span class='kw'>let</span> <span class='ident'>t</span> : ::<span class='ident'>RngType</span> <span class='op'>=</span> ::<span class='ident'>rng</span>::<span class='ident'>default</span>();
    <span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> ::<span class='ident'>Rng</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='ident'>t</span>).<span class='ident'>unwrap</span>();

    {
        <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>MiserMonteCarlo</span>::<span class='ident'>new</span>(<span class='number'>3</span>).<span class='ident'>unwrap</span>();

        <span class='kw'>let</span> (<span class='ident'>res</span>, <span class='ident'>err</span>) <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>integrate</span>(<span class='number'>3</span>, <span class='ident'>g</span>, <span class='kw-2'>&amp;</span><span class='ident'>xl</span>, <span class='kw-2'>&amp;</span><span class='ident'>xu</span>, <span class='ident'>calls</span>, <span class='kw-2'>&amp;</span><span class='ident'>r</span>).<span class='ident'>unwrap</span>();
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:.6}&quot;</span>, <span class='ident'>res</span>), <span class='string'>&quot;1.389530&quot;</span>);
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:.6}&quot;</span>, <span class='ident'>err</span>), <span class='string'>&quot;0.005011&quot;</span>);
    }
}

<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>miser_closure</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span>;

    <span class='kw'>let</span> <span class='ident'>xl</span> : [<span class='ident'>f64</span>; <span class='number'>3</span>] <span class='op'>=</span> [<span class='number'>0f64</span>; <span class='number'>3</span>];
    <span class='kw'>let</span> <span class='ident'>xu</span> : [<span class='ident'>f64</span>; <span class='number'>3</span>] <span class='op'>=</span> [<span class='ident'>PI</span>, <span class='ident'>PI</span>, <span class='ident'>PI</span>];

    <span class='kw'>let</span> <span class='ident'>calls</span> <span class='op'>=</span> <span class='number'>500000</span>;

    ::<span class='ident'>RngType</span>::<span class='ident'>env_setup</span>();
    <span class='kw'>let</span> <span class='ident'>t</span> : ::<span class='ident'>RngType</span> <span class='op'>=</span> ::<span class='ident'>rng</span>::<span class='ident'>default</span>();
    <span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> ::<span class='ident'>Rng</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='ident'>t</span>).<span class='ident'>unwrap</span>();

    {
        <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>MiserMonteCarlo</span>::<span class='ident'>new</span>(<span class='number'>3</span>).<span class='ident'>unwrap</span>();

        <span class='kw'>let</span> (<span class='ident'>res</span>, <span class='ident'>err</span>) <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>integrate</span>(<span class='number'>3</span>, <span class='op'>|</span><span class='ident'>k</span><span class='op'>|</span> {
                <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='number'>1f64</span> <span class='op'>/</span> (<span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>PI</span>);

                <span class='ident'>a</span> <span class='op'>/</span> (<span class='number'>1.0</span> <span class='op'>-</span> <span class='ident'>k</span>[<span class='number'>0</span>].<span class='ident'>cos</span>() <span class='op'>*</span> <span class='ident'>k</span>[<span class='number'>1</span>].<span class='ident'>cos</span>() <span class='op'>*</span> <span class='ident'>k</span>[<span class='number'>2</span>].<span class='ident'>cos</span>())
            }, <span class='kw-2'>&amp;</span><span class='ident'>xl</span>, <span class='kw-2'>&amp;</span><span class='ident'>xu</span>, <span class='ident'>calls</span>, <span class='kw-2'>&amp;</span><span class='ident'>r</span>).<span class='ident'>unwrap</span>();
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:.6}&quot;</span>, <span class='ident'>res</span>), <span class='string'>&quot;1.389530&quot;</span>);
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:.6}&quot;</span>, <span class='ident'>err</span>), <span class='string'>&quot;0.005011&quot;</span>);
    }
}

<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>vegas_warm_up</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span>;
    <span class='kw'>fn</span> <span class='ident'>g</span>(<span class='ident'>k</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='number'>1f64</span> <span class='op'>/</span> (<span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>PI</span>);

        <span class='ident'>a</span> <span class='op'>/</span> (<span class='number'>1.0</span> <span class='op'>-</span> <span class='ident'>k</span>[<span class='number'>0</span>].<span class='ident'>cos</span>() <span class='op'>*</span> <span class='ident'>k</span>[<span class='number'>1</span>].<span class='ident'>cos</span>() <span class='op'>*</span> <span class='ident'>k</span>[<span class='number'>2</span>].<span class='ident'>cos</span>())
    }

    <span class='kw'>let</span> <span class='ident'>xl</span> : [<span class='ident'>f64</span>; <span class='number'>3</span>] <span class='op'>=</span> [<span class='number'>0f64</span>; <span class='number'>3</span>];
    <span class='kw'>let</span> <span class='ident'>xu</span> : [<span class='ident'>f64</span>; <span class='number'>3</span>] <span class='op'>=</span> [<span class='ident'>PI</span>, <span class='ident'>PI</span>, <span class='ident'>PI</span>];

    ::<span class='ident'>RngType</span>::<span class='ident'>env_setup</span>();
    <span class='kw'>let</span> <span class='ident'>t</span> : ::<span class='ident'>RngType</span> <span class='op'>=</span> ::<span class='ident'>rng</span>::<span class='ident'>default</span>();
    <span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> ::<span class='ident'>Rng</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='ident'>t</span>).<span class='ident'>unwrap</span>();

    {
        <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>VegasMonteCarlo</span>::<span class='ident'>new</span>(<span class='number'>3</span>).<span class='ident'>unwrap</span>();

        <span class='kw'>let</span> (<span class='ident'>res</span>, <span class='ident'>err</span>) <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>integrate</span>(<span class='number'>3</span>, <span class='ident'>g</span>, <span class='kw-2'>&amp;</span><span class='ident'>xl</span>, <span class='kw-2'>&amp;</span><span class='ident'>xu</span>, <span class='number'>10000</span>, <span class='kw-2'>&amp;</span><span class='ident'>r</span>).<span class='ident'>unwrap</span>();
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:.6}&quot;</span>, <span class='ident'>res</span>), <span class='string'>&quot;1.385603&quot;</span>);
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:.6}&quot;</span>, <span class='ident'>err</span>), <span class='string'>&quot;0.002212&quot;</span>);
    }
}

<span class='attribute'>#[<span class='ident'>test</span>]</span>
<span class='kw'>fn</span> <span class='ident'>vegas</span>() {
    <span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>f64</span>::<span class='ident'>consts</span>::<span class='ident'>PI</span>;
    <span class='kw'>fn</span> <span class='ident'>g</span>(<span class='ident'>k</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
        <span class='kw'>let</span> <span class='ident'>a</span> <span class='op'>=</span> <span class='number'>1f64</span> <span class='op'>/</span> (<span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>PI</span> <span class='op'>*</span> <span class='ident'>PI</span>);

        <span class='ident'>a</span> <span class='op'>/</span> (<span class='number'>1.0</span> <span class='op'>-</span> <span class='ident'>k</span>[<span class='number'>0</span>].<span class='ident'>cos</span>() <span class='op'>*</span> <span class='ident'>k</span>[<span class='number'>1</span>].<span class='ident'>cos</span>() <span class='op'>*</span> <span class='ident'>k</span>[<span class='number'>2</span>].<span class='ident'>cos</span>())
    }

    <span class='kw'>let</span> <span class='ident'>calls</span> <span class='op'>=</span> <span class='number'>500000</span>;

    <span class='kw'>let</span> <span class='ident'>xl</span> : [<span class='ident'>f64</span>; <span class='number'>3</span>] <span class='op'>=</span> [<span class='number'>0f64</span>; <span class='number'>3</span>];
    <span class='kw'>let</span> <span class='ident'>xu</span> : [<span class='ident'>f64</span>; <span class='number'>3</span>] <span class='op'>=</span> [<span class='ident'>PI</span>, <span class='ident'>PI</span>, <span class='ident'>PI</span>];

    ::<span class='ident'>RngType</span>::<span class='ident'>env_setup</span>();
    <span class='kw'>let</span> <span class='ident'>t</span> : ::<span class='ident'>RngType</span> <span class='op'>=</span> ::<span class='ident'>rng</span>::<span class='ident'>default</span>();
    <span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> ::<span class='ident'>Rng</span>::<span class='ident'>new</span>(<span class='kw-2'>&amp;</span><span class='ident'>t</span>).<span class='ident'>unwrap</span>();

    {
        <span class='kw'>let</span> <span class='ident'>s</span> <span class='op'>=</span> <span class='ident'>VegasMonteCarlo</span>::<span class='ident'>new</span>(<span class='number'>3</span>).<span class='ident'>unwrap</span>();

        <span class='ident'>s</span>.<span class='ident'>integrate</span>(<span class='number'>3</span>, <span class='ident'>g</span>, <span class='kw-2'>&amp;</span><span class='ident'>xl</span>, <span class='kw-2'>&amp;</span><span class='ident'>xu</span>, <span class='number'>10000</span>, <span class='kw-2'>&amp;</span><span class='ident'>r</span>).<span class='ident'>unwrap</span>();
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>res</span>;
        <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>err</span>;
        <span class='kw'>loop</span> {
            <span class='kw'>let</span> (<span class='ident'>_res</span>, <span class='ident'>_err</span>) <span class='op'>=</span> <span class='ident'>s</span>.<span class='ident'>integrate</span>(<span class='number'>3</span>, <span class='ident'>g</span>, <span class='kw-2'>&amp;</span><span class='ident'>xl</span>, <span class='kw-2'>&amp;</span><span class='ident'>xu</span>, <span class='ident'>calls</span> <span class='op'>/</span> <span class='number'>5</span>, <span class='kw-2'>&amp;</span><span class='ident'>r</span>).<span class='ident'>unwrap</span>();
            <span class='ident'>res</span> <span class='op'>=</span> <span class='ident'>_res</span>;
            <span class='ident'>err</span> <span class='op'>=</span> <span class='ident'>_err</span>;
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;result = {:.6} sigma = {:.6} chisq/dof = {:.1}&quot;</span>, <span class='ident'>res</span>, <span class='ident'>err</span>, <span class='ident'>s</span>.<span class='ident'>chisq</span>());
            <span class='kw'>if</span> (<span class='ident'>s</span>.<span class='ident'>chisq</span>() <span class='op'>-</span> <span class='number'>1f64</span>).<span class='ident'>abs</span>() <span class='op'>&lt;=</span> <span class='number'>0.5f64</span> {
                <span class='kw'>break</span>;
            }
        }
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:.6}&quot;</span>, <span class='ident'>res</span>), <span class='string'>&quot;1.393307&quot;</span>);
        <span class='macro'>assert_eq</span><span class='macro'>!</span>(<span class='kw-2'>&amp;</span><span class='macro'>format</span><span class='macro'>!</span>(<span class='string'>&quot;{:.6}&quot;</span>, <span class='ident'>err</span>), <span class='string'>&quot;0.000335&quot;</span>);
    }
}
</pre>
</section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../../";
        window.currentCrate = "rgsl";
        window.playgroundUrl = "";
    </script>
    <script src="../../../jquery.js"></script>
    <script src="../../../main.js"></script>
    
    <script defer src="../../../search-index.js"></script>
</body>
</html>