<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="Source to the Rust file `/home/travis/.cargo/registry/src/github.com-1ecc6299db9ec823/GSL-0.4.28/src/statistics.rs`.">
    <meta name="keywords" content="rust, rustlang, rust-lang">

    <title>statistics.rs.html -- source</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content source"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
</pre><pre class='rust '>
<span class='comment'>//</span>
<span class='comment'>// A rust binding for the GSL library by Guillaume Gomez (guillaume1.gomez@gmail.com)</span>
<span class='comment'>//</span>

<span class='doccomment'>/*!
#Statistics

This chapter describes the statistical functions in the library. The basic statistical functions include routines to compute the mean, 
variance and standard deviation. More advanced functions allow you to calculate absolute deviations, skewness, and kurtosis as well as the 
median and arbitrary percentiles. The algorithms use recurrence relations to compute average quantities in a stable way, without large 
intermediate values that might overflow.

##Weighted Samples

The functions described in this section allow the computation of statistics for weighted samples. The functions accept an array of 
samples, x_i, with associated weights, w_i. Each sample x_i is considered as having been drawn from a Gaussian distribution with variance 
\sigma_i^2. The sample weight w_i is defined as the reciprocal of this variance, w_i = 1/\sigma_i^2. Setting a weight to zero corresponds 
to removing a sample from a dataset.

##Maximum and Minimum values

The following functions find the maximum and minimum values of a dataset (or their indices). If the data contains NaNs then a NaN will be 
returned, since the maximum or minimum value is undefined. For functions which return an index, the location of the first NaN in the array is returned.

##Median and Percentiles

The median and percentile functions described in this section operate on sorted data. For convenience we use quantiles, measured on a 
scale of 0 to 1, instead of percentiles (which use a scale of 0 to 100).

##References and Further Reading

The standard reference for almost any topic in statistics is the multi-volume Advanced Theory of Statistics by Kendall and Stuart.

Maurice Kendall, Alan Stuart, and J. Keith Ord. The Advanced Theory of Statistics (multiple volumes) reprinted as Kendall’s Advanced 
Theory of Statistics. Wiley, ISBN 047023380X.
Many statistical concepts can be more easily understood by a Bayesian approach. The following book by Gelman, Carlin, Stern and Rubin 
gives a comprehensive coverage of the subject.

Andrew Gelman, John B. Carlin, Hal S. Stern, Donald B. Rubin. Bayesian Data Analysis. Chapman &amp; Hall, ISBN 0412039915.
For physicists the Particle Data Group provides useful reviews of Probability and Statistics in the “Mathematical Tools” section of its 
Annual Review of Particle Physics.

Review of Particle Properties R.M. Barnett et al., Physical Review D54, 1 (1996)
The Review of Particle Physics is available online at the website http://pdg.lbl.gov/.
!*/</span>

<span class='kw'>use</span> <span class='ident'>ffi</span>;

<span class='doccomment'>/// This function returns the arithmetic mean of data, a dataset of length n with stride stride. The arithmetic mean, or sample mean, is</span>
<span class='doccomment'>/// denoted by \Hat\mu and defined as,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// \Hat\mu = (1/N) \sum x_i</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// where x_i are the elements of the dataset data. For samples drawn from a gaussian distribution the variance of \Hat\mu is \sigma^2 / N.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>mean</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_mean</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns the estimated, or sample, variance of data, a dataset of length n with stride stride. The estimated variance is</span>
<span class='doccomment'>/// denoted by \Hat\sigma^2 and is defined by,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// \Hat\sigma^2 = (1/(N-1)) \sum (x_i - \Hat\mu)^2</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// where x_i are the elements of the dataset data. Note that the normalization factor of 1/(N-1) results from the derivation of</span>
<span class='doccomment'>/// \Hat\sigma^2 as an unbiased estimator of the population variance \sigma^2. For samples drawn from a Gaussian distribution the</span>
<span class='doccomment'>/// variance of \Hat\sigma^2 itself is 2 \sigma^4 / N.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// This function computes the mean via a call to gsl_stats_mean. If you have already computed the mean then you can pass it directly to</span>
<span class='doccomment'>/// gsl_stats_variance_m.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>variance</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_variance</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns the sample variance of data relative to the given value of mean. The function is computed with \Hat\mu replaced</span>
<span class='doccomment'>/// by the value of mean that you supply,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// \Hat\sigma^2 = (1/(N-1)) \sum (x_i - mean)^2</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>variance_m</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>mean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_variance_m</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>mean</span>) }
}

<span class='doccomment'>/// The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding</span>
<span class='doccomment'>/// variance functions above.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>sd</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_sd</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding</span>
<span class='doccomment'>/// variance functions above.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>sd_m</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>mean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_sd_m</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>mean</span>) }
}

<span class='doccomment'>/// This function returns the total sum of squares (TSS) of data about the mean. For gsl_stats_tss_m the user-supplied value of mean is</span>
<span class='doccomment'>/// used, and for gsl_stats_tss it is computed using gsl_stats_mean.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// TSS =  \sum (x_i - mean)^2</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>tss</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_tss</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns the total sum of squares (TSS) of data about the mean. For gsl_stats_tss_m the user-supplied value of mean is</span>
<span class='doccomment'>/// used, and for gsl_stats_tss it is computed using gsl_stats_mean.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// TSS =  \sum (x_i - mean)^2</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>tss_m</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>mean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_tss_m</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>mean</span>) }
}

<span class='doccomment'>/// This function computes an unbiased estimate of the variance of data when the population mean mean of the underlying distribution is</span>
<span class='doccomment'>/// known a priori. In this case the estimator for the variance uses the factor 1/N and the sample mean \Hat\mu is replaced by the known</span>
<span class='doccomment'>/// population mean \mu,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// \Hat\sigma^2 = (1/N) \sum (x_i - \mu)^2</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>variance_with_fixed_mean</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>mean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_variance_with_fixed_mean</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>mean</span>) }
}

<span class='doccomment'>/// This function calculates the standard deviation of data for a fixed population mean mean. The result is the square root of the</span>
<span class='doccomment'>/// corresponding variance function.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>sd_with_fixed_mean</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>mean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_sd_with_fixed_mean</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>mean</span>) }
}

<span class='doccomment'>/// This function computes the absolute deviation from the mean of data, a dataset of length n with stride stride. The absolute deviation</span>
<span class='doccomment'>/// from the mean is defined as,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// absdev  = (1/N) \sum |x_i - \Hat\mu|</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// where x_i are the elements of the dataset data. The absolute deviation from the mean provides a more robust measure of the width of a</span>
<span class='doccomment'>/// distribution than the variance. This function computes the mean of data via a call to gsl_stats_mean.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>absdev</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_absdev</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function computes the absolute deviation of the dataset data relative to the given value of mean,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// absdev  = (1/N) \sum |x_i - mean|</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// This function is useful if you have already computed the mean of data (and want to avoid recomputing it), or wish to calculate the</span>
<span class='doccomment'>/// absolute deviation relative to another value (such as zero, or the median).</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>absdev_m</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>mean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_absdev_m</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>mean</span>) }
}

<span class='doccomment'>/// This function computes the skewness of data, a dataset of length n with stride stride. The skewness is defined as,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// skew = (1/N) \sum ((x_i - \Hat\mu)/\Hat\sigma)^3</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// where x_i are the elements of the dataset data. The skewness measures the asymmetry of the tails of a distribution.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// The function computes the mean and estimated standard deviation of data via calls to gsl_stats_mean and gsl_stats_sd.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>skew</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_skew</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function computes the skewness of the dataset data using the given values of the mean mean and standard deviation sd,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// skew = (1/N) \sum ((x_i - mean)/sd)^3</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// These functions are useful if you have already computed the mean and standard deviation of data and want to avoid recomputing them.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>skew_m_sd</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>mean</span>: <span class='ident'>f64</span>, <span class='ident'>sd</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_skew_m_sd</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>mean</span>, <span class='ident'>sd</span>) }
}

<span class='doccomment'>/// This function computes the kurtosis of data, a dataset of length n with stride stride. The kurtosis is defined as,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// kurtosis = ((1/N) \sum ((x_i - \Hat\mu)/\Hat\sigma)^4)  - 3</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// The kurtosis measures how sharply peaked a distribution is, relative to its width. The kurtosis is normalized to zero for a Gaussian distribution.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>kurtosis</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_kurtosis</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function computes the kurtosis of the dataset data using the given values of the mean mean and standard deviation sd,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// kurtosis = ((1/N) \sum ((x_i - mean)/sd)^4) - 3</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// This function is useful if you have already computed the mean and standard deviation of data and want to avoid recomputing them.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>kurtosis_m_sd</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>mean</span>: <span class='ident'>f64</span>, <span class='ident'>sd</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_kurtosis_m_sd</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>mean</span>, <span class='ident'>sd</span>) }
}

<span class='doccomment'>/// This function computes the lag-1 autocorrelation of the dataset data.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// a_1 = {\sum_{i = 1}^{n} (x_{i} - \Hat\mu) (x_{i-1} - \Hat\mu)</span>
<span class='doccomment'>///        \over</span>
<span class='doccomment'>///        \sum_{i = 1}^{n} (x_{i} - \Hat\mu) (x_{i} - \Hat\mu)}</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>lag1_autocorrelation</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_lag1_autocorrelation</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function computes the lag-1 autocorrelation of the dataset data using the given value of the mean mean.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>lag1_autocorrelation_m</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>mean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_lag1_autocorrelation_m</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>mean</span>) }
}

<span class='doccomment'>/// This function computes the covariance of the datasets data1 and data2 which must both be of the same length n.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// covar = (1/(n - 1)) \sum_{i = 1}^{n} (x_i - \Hat x) (y_i - \Hat y)</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>covariance</span>(<span class='ident'>data1</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride1</span>: <span class='ident'>usize</span>, <span class='ident'>data2</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride2</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_covariance</span>(<span class='ident'>data1</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride1</span>, <span class='ident'>data2</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride2</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function computes the covariance of the datasets data1 and data2 using the given values of the means, mean1 and mean2. This is</span>
<span class='doccomment'>/// useful if you have already computed the means of data1 and data2 and want to avoid recomputing them.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>covariance_m</span>(<span class='ident'>data1</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride1</span>: <span class='ident'>usize</span>, <span class='ident'>data2</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride2</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>mean1</span>: <span class='ident'>f64</span>, <span class='ident'>mean2</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_covariance_m</span>(<span class='ident'>data1</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride1</span>, <span class='ident'>data2</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride2</span>, <span class='ident'>n</span>, <span class='ident'>mean1</span>, <span class='ident'>mean2</span>) }
}

<span class='doccomment'>/// This function efficiently computes the Pearson correlation coefficient between the datasets data1 and data2 which must both be of the</span>
<span class='doccomment'>/// same length n.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// r = cov(x, y) / (\Hat\sigma_x \Hat\sigma_y)</span>
<span class='doccomment'>///   = {1/(n-1) \sum (x_i - \Hat x) (y_i - \Hat y)</span>
<span class='doccomment'>///      \over</span>
<span class='doccomment'>///      \sqrt{1/(n-1) \sum (x_i - \Hat x)^2} \sqrt{1/(n-1) \sum (y_i - \Hat y)^2}</span>
<span class='doccomment'>///     }</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>correlation</span>(<span class='ident'>data1</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride1</span>: <span class='ident'>usize</span>, <span class='ident'>data2</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride2</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_correlation</span>(<span class='ident'>data1</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride1</span>, <span class='ident'>data2</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride2</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function computes the Spearman rank correlation coefficient between the datasets data1 and data2 which must both be of the same</span>
<span class='doccomment'>/// length n. Additional workspace of size 2*n is required in work. The Spearman rank correlation between vectors x and y is equivalent to</span>
<span class='doccomment'>/// the Pearson correlation between the ranked vectors x_R and y_R, where ranks are defined to be the average of the positions of an</span>
<span class='doccomment'>/// element in the ascending order of the values.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>spearman</span>(<span class='ident'>data1</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride1</span>: <span class='ident'>usize</span>, <span class='ident'>data2</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride2</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>work</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> [<span class='ident'>f64</span>]) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_spearman</span>(<span class='ident'>data1</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride1</span>, <span class='ident'>data2</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride2</span>, <span class='ident'>n</span>, <span class='ident'>work</span>.<span class='ident'>as_mut_ptr</span>()) }
}

<span class='doccomment'>/// This function returns the weighted mean of the dataset data with stride stride and length n, using the set of weights w with stride</span>
<span class='doccomment'>/// wstride and length n. The weighted mean is defined as,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// \Hat\mu = (\sum w_i x_i) / (\sum w_i)</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wmean</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wmean</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns the estimated variance of the dataset data with stride stride and length n, using the set of weights w with</span>
<span class='doccomment'>/// stride wstride and length n. The estimated variance of a weighted dataset is calculated as,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// \Hat\sigma^2 = ((\sum w_i)/((\sum w_i)^2 - \sum (w_i^2))) </span>
<span class='doccomment'>///                 \sum w_i (x_i - \Hat\mu)^2</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// Note that this expression reduces to an unweighted variance with the familiar 1/(N-1) factor when there are N equal non-zero weights.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wvariance</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wvariance</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns the estimated variance of the weighted dataset data using the given weighted mean wmean.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wvariance_m</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>wmean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wvariance_m</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>wmean</span>) }
}

<span class='doccomment'>/// The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding</span>
<span class='doccomment'>/// variance function gsl_stats_wvariance above.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wsd</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wsd</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns the square root of the corresponding variance function gsl_stats_wvariance_m above.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wsd_m</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>wmean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wsd_m</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>wmean</span>) }
}

<span class='doccomment'>/// This function computes an unbiased estimate of the variance of the weighted dataset data when the population mean mean of the</span>
<span class='doccomment'>/// underlying distribution is known a priori. In this case the estimator for the variance replaces the sample mean \Hat\mu by the known</span>
<span class='doccomment'>/// population mean \mu,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// \Hat\sigma^2 = (\sum w_i (x_i - \mu)^2) / (\sum w_i)</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wvariance_with_fixed_mean</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>mean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wvariance_with_fixed_mean</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>mean</span>) }
}

<span class='doccomment'>/// The standard deviation is defined as the square root of the variance. This function returns the square root of the corresponding</span>
<span class='doccomment'>/// variance function above.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wsd_with_fixed_mean</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>mean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wsd_with_fixed_mean</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>mean</span>) }
}

<span class='doccomment'>/// This function returns the weighted total sum of squares (TSS) of data about the weighted mean. For gsl_stats_wtss_m the user-supplied</span>
<span class='doccomment'>/// value of wmean is used, and for gsl_stats_wtss it is computed using gsl_stats_wmean.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// TSS =  \sum w_i (x_i - wmean)^2</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wtss</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wtss</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns the weighted total sum of squares (TSS) of data about the weighted mean. For gsl_stats_wtss_m the user-supplied</span>
<span class='doccomment'>/// value of wmean is used, and for gsl_stats_wtss it is computed using gsl_stats_wmean.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// TSS =  \sum w_i (x_i - wmean)^2</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wtss_m</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>wmean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wtss_m</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>wmean</span>) }
}

<span class='doccomment'>/// This function computes the weighted absolute deviation from the weighted mean of data. The absolute deviation from the mean is defined</span>
<span class='doccomment'>/// as,</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// absdev = (\sum w_i |x_i - \Hat\mu|) / (\sum w_i)</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wabsdev</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wabsdev</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function computes the absolute deviation of the weighted dataset data about the given weighted mean wmean.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wabsdev_m</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>wmean</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wabsdev_m</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>wmean</span>) }
}

<span class='doccomment'>/// This function computes the weighted skewness of the dataset data.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// skew = (\sum w_i ((x_i - \Hat x)/\Hat \sigma)^3) / (\sum w_i)</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wskew</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wskew</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function computes the weighted skewness of the dataset data using the given values of the weighted mean and weighted standard</span>
<span class='doccomment'>/// deviation, wmean and wsd.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wskew_m_sd</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>wmean</span>: <span class='ident'>f64</span>, <span class='ident'>wsd</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wskew_m_sd</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>wmean</span>, <span class='ident'>wsd</span>) }
}

<span class='doccomment'>/// This function computes the weighted kurtosis of the dataset data.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// kurtosis = ((\sum w_i ((x_i - \Hat x)/\Hat \sigma)^4) / (\sum w_i)) - 3</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wkurtosis</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wkurtosis</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function computes the weighted kurtosis of the dataset data using the given values of the weighted mean and weighted standard</span>
<span class='doccomment'>/// deviation, wmean and wsd.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>wkurtosis_m_sd</span>(<span class='ident'>w</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>wstride</span>: <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>wmean</span>: <span class='ident'>f64</span>, <span class='ident'>wsd</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_wkurtosis_m_sd</span>(<span class='ident'>w</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>wstride</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>wmean</span>, <span class='ident'>wsd</span>) }
}

<span class='doccomment'>/// This function returns the maximum value in data, a dataset of length n with stride stride. The maximum value is defined as the value</span>
<span class='doccomment'>/// of the element x_i which satisfies x_i &gt;= x_j for all j.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// If you want instead to find the element with the largest absolute magnitude you will need to apply fabs or abs to your data before</span>
<span class='doccomment'>/// calling this function.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>max</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_max</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns the minimum value in data, a dataset of length n with stride stride. The minimum value is defined as the value</span>
<span class='doccomment'>/// of the element x_i which satisfies x_i &lt;= x_j for all j.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// If you want instead to find the element with the smallest absolute magnitude you will need to apply fabs or abs to your data before</span>
<span class='doccomment'>/// calling this function.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>min</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_min</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function finds both the minimum and maximum values min, max in data in a single pass.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>minmax</span>(<span class='ident'>min</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>f64</span>, <span class='ident'>max</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>f64</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_minmax</span>(<span class='ident'>min</span>, <span class='ident'>max</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns the index of the maximum value in data, a dataset of length n with stride stride. The maximum value is defined</span>
<span class='doccomment'>/// as the value of the element x_i which satisfies x_i &gt;= x_j for all j. When there are several equal maximum elements then the first</span>
<span class='doccomment'>/// one is chosen.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>max_index</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_max_index</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns the index of the minimum value in data, a dataset of length n with stride stride. The minimum value is defined</span>
<span class='doccomment'>/// as the value of the element x_i which satisfies x_i &gt;= x_j for all j. When there are several equal minimum elements then the first</span>
<span class='doccomment'>/// one is chosen.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>min_index</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>usize</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_min_index</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns the indexes min_index, max_index of the minimum and maximum values in data in a single pass.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>minmax_index</span>(<span class='ident'>min_index</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>usize</span>, <span class='ident'>max_index</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>usize</span>, <span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_minmax_index</span>(<span class='ident'>min_index</span>, <span class='ident'>max_index</span>, <span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns the median value of sorted_data, a dataset of length n with stride stride. The elements of the array must be in</span>
<span class='doccomment'>/// ascending numerical order. There are no checks to see whether the data are sorted, so the function gsl_sort should always be used</span>
<span class='doccomment'>/// first.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// When the dataset has an odd number of elements the median is the value of element (n-1)/2. When the dataset has an even number of</span>
<span class='doccomment'>/// elements the median is the mean of the two nearest middle values, elements (n-1)/2 and n/2. Since the algorithm for computing the</span>
<span class='doccomment'>/// median involves interpolation this function always returns a floating-point number, even for integer data types.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>median_from_sorted_data</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_median_from_sorted_data</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>) }
}

<span class='doccomment'>/// This function returns a quantile value of sorted_data, a double-precision array of length n with stride stride. The elements of the</span>
<span class='doccomment'>/// array must be in ascending numerical order. The quantile is determined by the f, a fraction between 0 and 1. For example, to compute</span>
<span class='doccomment'>/// the value of the 75th percentile f should have the value 0.75.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// There are no checks to see whether the data are sorted, so the function gsl_sort should always be used first.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// The quantile is found by interpolation, using the formula</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// quantile = (1 - \delta) x_i + \delta x_{i+1}</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// where i is floor((n - 1)f) and \delta is (n-1)f - i.</span>
<span class='doccomment'>/// </span>
<span class='doccomment'>/// Thus the minimum value of the array (data[0*stride]) is given by f equal to zero, the maximum value (data[(n-1)*stride]) is given by</span>
<span class='doccomment'>/// f equal to one and the median value is given by f equal to 0.5. Since the algorithm for computing quantiles involves interpolation</span>
<span class='doccomment'>/// this function always returns a floating-point number, even for integer data types.</span>
<span class='kw'>pub</span> <span class='kw'>fn</span> <span class='ident'>quantile_from_sorted_data</span>(<span class='ident'>data</span>: <span class='kw-2'>&amp;</span>[<span class='ident'>f64</span>], <span class='ident'>stride</span>: <span class='ident'>usize</span>, <span class='ident'>n</span>: <span class='ident'>usize</span>, <span class='ident'>f</span>: <span class='ident'>f64</span>) <span class='op'>-&gt;</span> <span class='ident'>f64</span> {
    <span class='kw'>unsafe</span> { <span class='ident'>ffi</span>::<span class='ident'>gsl_stats_quantile_from_sorted_data</span>(<span class='ident'>data</span>.<span class='ident'>as_ptr</span>(), <span class='ident'>stride</span>, <span class='ident'>n</span>, <span class='ident'>f</span>) }
}</pre>
</section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "rgsl";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script defer src="../../search-index.js"></script>
</body>
</html>